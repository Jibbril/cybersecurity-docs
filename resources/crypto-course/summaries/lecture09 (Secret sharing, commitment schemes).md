# Lecture 9

### Property wishlist for keys
The property wishlist for keys is that they would be 
1. Readily available
2. Secure

### Secret sharing
To enable the wishlist above, one koncept is to split the keys up into several parts and distribute them. That way, the key is available to be reconstructed by someone who has all of the parts, but there is a lower chance of a single malicious actor getting all the parts. 

To formalise this idea we introduce the concept of _shares_. A function $`Share(s) \rightarrow \{s_1, \dots, s_n \}`$ takes in some secret $s$ and outputs $n$ shares $`s_i`$ that can then be used to reconstruct the secret $`s = Reconstruct(s_1, \dots, s_n)`$. 

### Threshold Secret Sharing
We can build on the concept of secret sharing to introduce two functions $Share$ and $Reconstruct$, however, we can create $Reconstruct$ in such a way that it doesn't need all $n$ shares to reconstruct $s$, some smaller number $t$ can be enough. 

For such an t-out-of-n-secret sharing scheme, the following properties must hold:

- $t$-correctness: Any set of $t$ shares can reconstruct $s$
  - $`Pr[Reconstruct(s_{i_1}, \dots, s_{i_t}) = s | (s_1, \dots, s_n \leftarrow Shared(s)] = 1 \; \forall \{ i_1, \dots , i_t\} \subset \{1, \dots, n\}`$
- $(t-1)$-security: Any subset of less than $t$ parties cannot compute $s$
  - For all sets $`J \in \{ 1,\dots, n \}`$ with $|J| < t$ it holds that the probability that any set in $J$ has equal probability of coming from any secret $s$. Very similar to how perfect secrecy says that any ciphertext should have equal probability to have been generated by any specific message. 

### Additive $t$-out-of-$n$ Secret Sharing
A basic threshold secret sharing scheme can be given by defining
```math
\begin{align*}
    &Share(s): \; s_1, \dots, s_{n-1} \leftarrow \$ Z_N, \; s_n = s - (s_1 + \dots + s_{n-1}) \mod N \quad \text{where} \; s_1, \dots, s_n \in Z_N \\
    &Reconstruct(s_1, \dots, s_n): \; s = s_1 + \dots + s_n \mod N
\end{align*}
```
Every operation above is efficient (modulo), we have $t$-correctness as well as $(t-1)$-security, as such the scheme is valid. 

### Shamir Secret Sharing (intuition)
To expand on the previous idea, we can introduce polynomials to create shares. To do this, we rely on the mathematical fact that if we have $d$ points in a graph, then only one polynomial of degree $d+1$ exists that passes through all $d$ points. 

We start by setting some secret value $s$. We then create a random polynomial of degree $t-1$ that passes through the point $(0,s)$. To compute the shares we can now say that $`s_i = f(i)`$ where $f$ is our polynomial and $i \in N$. By doing this we ensure that we can only reconstruct the original point $(0,s)$ by having access to all $t$ $`s_i`$, and thus being able to construct the only existing polynomial of degree $d-1$ that will fit all the datapoints. Consequently, the secret value $s$ is secure unless are shares are known. 

### Shamir Secret Sharing (formal)
To $Share(s)$ given the value $`s \in Z_p`$ where $p$ is a prime and $p>n$, do:
- Sample $t-1$ random values $`a_1, \dots, a_{t-1} \leftarrow \$Z_p`$ with $`a_{t-1} \neq 0`$
- Construct the polynomial $`f(x) = s + a_1 x + a_2 x^2 + \dots + a_{t-1} x^{t-1} \in Z_p [x]`$
- Compute the n shares by evaluating $f(x)$ on $n$ distinct points $`s_i = f(i)`$ for $`i \in \{1, \dots , n\}`$
- Send the shares $`s_i`$ to the party $`P_i`$ via a secure channel

To $`Reconstruct(s_{i_1}, \dots, s_{i_t})`$, let $`I = \{i_1, \dots, i_t\}`$ be the set of distinct indexes. Do:
- Compute the Lagrange coefficients for the set $I$: $`L_i^I(0) = \prod_{j \in I \backslash \{i\}} \frac{j}{j-i} \mod p`$
- Recover the secret $`s = \Sigma_{i \in I} s_i \cdot L_i^I(0) \mod p`$

### Lagrange coefficients
In the Shamir secret sharing scheme we utilize Lagrange coefficients which are defined over the set $I$ as
```math
\begin{equation*}
    L_i^I(x) = \prod_{j \in J \backslash \{i\}} \frac{j - x}{j - i} \mod p
\end{equation*}
```
The key points to note here are that 
- The Polynomial $f(x)$ and the sum of all the Lagrange coefficients coincide on $d+1$ points.
- The Lagrange coefficients only depend on $i,j \in I$ and not $f(x)$
- By setting $x = 0$ we get $`s = f(0) = f(i_1)L_{i_1}^I(0) + \dots + f(i_t) L_{i_t}^I(0) \mod p`$

### Elgamal's Threshold Cryptosystem
Building on the ideas from Shamir secret sharing we can now construct Elgamal's threshold cryptosystem. It consists of the following steps:

- Let $g$ be a generator of a a group $G$ of large prime order $q$
- Sample a secret key $sk$ uniformly from $G$ while excluding 1 and $q$.
- Set the public key $`pk = g^{sk}`$
- Use Shamir secret sharing to create shares $`s_1, \dots, s_n`$ and securely send the them to the corresponding parties.
- Sample some random number $r$ uniformly from $G$ while excluding $1$ and $q$
- Encrypt the desired message $m$ into a ciphertext $`c = (g^r, m \cdot pk^r)`$, same as in Elgamal encryption
- A party with a singular share $`s_k`$ can now parse $c$ and compute $`d_i = c_1^{sk_i}`$
- Collaborate with the other parties to get $`Dec(I, \{d_i\}_{i \in I}, c_2)`$
- We can now compute $`D = \prod_{i \in I} d_i^{L_i^I (0)} = g^{r \Sigma_{i \in I} sk_i \cdot L_i^I(0) \mod q} = g^{r \cdot sk}`$
- Finally, output $`m = c_2 \cdot D^{-1}`$


### Commitment schemes
A commitment scheme is a protocol between two (or more) parties where a sender commits to some message at a certain point in time, that will only be revealed at a later point in time. An intuition can be playing rock-paper-scissors via email. Each player needs to commit to their choice before seeing the other person's choice, else cheating is inevitable. 

The general idea goes as follows: 
- The sender commits to some value $m$ and encrypts it into $c = Commit(m, r)$ for some random value $r$.
- The sender sends $c$ to the receiver
- In the reveal phase, the sender sends $(m,r)$ to the receiver who can then verify that the initially received $c = Commit(m,r)$. 

### Formal commitment scheme properties
To formalise a commitment scheme we will consider the notions of binding and hiding. 

A commitment scheme is binding if no adversary can find two messages $`m \neq m^*`$ and randomness $`r,r^*`$ s.t. $`c = Commit(m,r) = Commit(m^*, r^*)`$.

We also differentiate between computationally binding and information-theoretically binding depending on the implementation.

A commitment scheme is said to be _hiding_ if no adversary can consistently win a game similar to IND-CPA where they can send two messages to the challenger, the challenger commits one of them randomly and returns to the adversary, and the adversary then has to guess which message was commited. 

### Pedersen Commitment Scheme
The Pedersen commitment scheme is a well known scheme characterized by the following:

- Let $G = \langle g \rangle$ be a cyclic multiplicative subgroup of prime order $q$ inside the multiplicative group $`Z_p^*`$. 
- Let $h$ be a random element in $G \backslash g$. 
- Let $p,q,g,h$ be public information
- We then have $`c = Commit(m,r) = g^m h^r \mod p`$

This scheme is binding by virtue of the discrete logarithm problem which an adversary would need to break to create a new combination of $`(m^*,r^*)`$, and it is information-theoretically binding (even if the adversary could solve DL) which can be shown through a proof by contradiction on assuming that there exists $`r_0, r_1`$ s.t. $`c = g^{m_0} h^{r_0} = g^{m_1} h^{r_1}`$.

### Commitment schemes and hashes
It is possible to construct a commitment scheme based on hash functions. The general idea is the same as for the previous schemes, but here we need to add some randomness to the original message. So we $Commit(m \| r)$. Then in the reveal phase we reveal both $m,r$ and the hash function used so the other participants can verify.
