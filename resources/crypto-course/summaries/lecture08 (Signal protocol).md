# Lecture 8

### The Signal Protocol
The Signal Protocol is a widely used (Whatsapp, Facebook, etc) cryptographic protocol that enables secure end-to-end encryption for instant messages. A key feature of Signal is that it has relatively good guarantees for both _forward secrecy_ and _backward secrecy_. Meaning that if a breach occurs, the adversary can only read data close to the time that the breach occurred. The adversary will not be able to read data far in the past or far into the future. This property is also called having a small _healing window_.

### Three-way Diffie-Hellman (X3DH)
One of the building blocks of the Signal protocol is the Three-Way Diffie-Hellman (X3DH) protocol. X3DH is an expansion of the regular DH to include a server as a third party. This enables the key exchanges to be performed in an asynchronous way, which in turn allows the key exchange and subsequent secure messaging to occur even if both participants are not online at the same time. 

The Signal protocol relies on several different pairs of keys
- One long term identity key pair $`(pk,sk)`$ that persist for the duration of the user's account
- One medium term prekey pair $`(mtpk,mtsk)`$ that persist for weeks/months (similar to session cookies)
- Multiple one-time key pairs $`(otpk^{(i)}, otsk^{(i)})`$

All of these, including a set of one-time key pairs are generated when the user registers to use the system. The keys themselves are generated in a regular DH way by taking some $`sk \leftarrow Z_q^*`$ and $`pk = g^{sk} \in G`$.

### Walkthrough of the Signal Protocol
#### Master Secret generation
If Alice and Bob want to communicate using the Signal protocol, they first sign up using the X3DH procedure described above. They generate their various keys, and then send the public keys $`(pk, mtpk, otpk^1, otpk^2, \dots)`$ to the server for storage. 

If Alice wants to send a message to Bob, she queries the server, which in turn returns Bob's public key, his medium-term public key, his signature and one of his one-time public keys $`(pk_B, mtpk_B, sgn_B, otpk_B^{(i)})`$. 

To continue, Alice will then generate a payload $(i, AD)$ that she sends to Bob where $i$ is the index of which of Bob's one-time keys she used, and 
```math
\begin{equation*}
    AD = pk_A \| epk_A
\end{equation*}
```
where $`epk_A`$ is an ephemeral key generated by Alice. She also creates a master secret $ms$ by applying the known Key Derivation Function (KDF) to a combination of keys like below
```math
\begin{align*}
    ms &= KDF(ms_{AB}) \\
    ms_{AB} &= mtpk_B^{sk_A} \| pk_B^{epk_A} \| (mtpk_B)^{epk_A} \| (otpk_B^{(i)})^{eph_A}
\end{align*}
```

Upon receiving $(i,AD)$, Bob can generate the corresponding $ms$ 
```math
\begin{align*}
    (pk_A, eph_A) &= AD \\
    ms_{AB} &= pk_A^{mtsk_B} \| eph_A^{sk_B} \| eph_A^{mtsk_B} \| eph_A^{otsk_B^{(i)}} \\
    ms &= KDF(ms_{AB})
\end{align*}
```

This way, Alice and Bob have shared an initial master secret $ms$.

#### Message structure
To understand how this secret is used when encrypting messages we first need to survey the structure of messages. In the Signal protocol, messages are seen as tuples signifying positions in a table. So imagine we had the following chat history 

- Alice: "Hello"
- Alice: "Nice to meet you!"
- Bob: "Hello Alice"
- Bob: "Nice to meet you too."
- Bob: "How is your day?"
- Alice: "Great!"

That would be seen as the table 

| Msg 0  | Msg 1   | Msg 2   |
|-------------- | -------------- | -------------- |
| "Hello"    | "Nice to meet you!"     |      |
| "Hello Alice"    | "Nice to meet you too."     | "How is your day?"     |
| "Great!"    | | |

So each new line represents the sender switching, whereas each new column represents an additional message being sent by the same user before the other responds. A more general way of representing this would be by indexing the messages like 

| Msg 0  | Msg 1   | Msg 2   |
|-------------- | -------------- | -------------- |
| $`m_{00}`$ | $`m_{01}`$ |      |
| $`m_{10}`$ | $`m_{11}`$ | $`m_{12}`$ |
| $`m_{20}`$ | | |

#### Ratchets
Another key part of the Signal protocol are the assymetric and assymetric KDFs or ratchets. These are the foundation of the encryption used in Signal, and also the reason why Signal guarantees future and backwards security. 

The symmetric ratchet is a function $KDF_2$ which accepts a chaining key $`ck^{(i,j)}`$ and outputs a subsequent chaining key as well as an encryption key.

```math
\begin{equation*} 
    KDF_2(c^{(i,j)}) = (c^{(i,j + 1)}, k^{(i,j)})
\end{equation*} 
```

The assymetric ratchet is a complementary function that accepts a previous root key $`r^{(i)}`$ as well as a DH key $`k_{DH}^{(i+1)}`$ and outputs a subsequent root key $`r^{(i+1)}`$ as well as an initial chaining key $`ck^{(i+1,0)}`$.
```math
\begin{equation*}
    KDF_1(rk^{(i)}, k_{DH}^{(i+1)}) = (rk^{(i+1)}, ck^{(i + 1, 0)})
\end{equation*}
```
where 

```math
\begin{equation*}
    k_{DH}^{(i)} = (rchpk_B^{(i-1)})^{rchsk_A^{(i)}}
    = (rchpk_A^{(i)})^{rchsk_B^{(i-1)}}
\end{equation*}
```
for some 
```math
\begin{align*}
    rchsk^{(x)} &= y \leftarrow \$ - Z_q \\
    rchpk^{(x)} &= g^y \in G
\end{align*}
```

By combining these two ratchets, the Signal protocol continuously produces new keys to encrypt the oncoming messages with. The assymetric ratchet is used to produce a new row in the table, whereas the symmetric ratchet is used to produce new column values. Since each row of the assymetric ratchet is dependant on the previous, the initial row takes in the master secret $ms$ as well as the medium-term key $mtpk$ of the other party. 

#### Security guarantees
Due to the chaining nature of the ratchets continually inserting new randomness as new messages come in, the Signal protocol can guarantee quite a good amount of security.

If an attacker gains access to a user's memory they might be able to find $`ck^{(x,y)}, rk^{(x+1)}`$ and $`rchsk^{(x)}`$. Using these, the adversary can derive the future encryption keys, but only for the current and subsequent iterations of the assymetric ratchet. This means that the healing window for the Signal protocol is just two iterations of the assymetric ratchet. 
